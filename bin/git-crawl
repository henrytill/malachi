#!/usr/bin/env perl

use strict;
use warnings;
use feature 'signatures';

use Cwd;
use File::Basename;
use Getopt::Std;
use Git;

my $debug = 0;

sub usage() {
    print STDERR <<EOF;
Usage: $0 [-d]

Options:
    -d          Enable debug output
EOF
    exit 1;
}

sub dbg($msg) {
    print STDERR "[DEBUG] $msg\n" if $debug;
}

sub getruntimedir() {
    my $uid = $<;
    my $runtimedir = $ENV{XDG_RUNTIME_DIR} || "/run/user/$uid";
    if (-d $runtimedir && -w $runtimedir) {
        return "$runtimedir/malachi";
    }
    my $tmpdir = $ENV{TMPDIR} || "/tmp";
    return "$tmpdir/malachi-$uid";
}

sub firstrun($gitrepo, $head, $fh = \*STDOUT) {
    dbg("first run - generating add events for all files");
    my $repo = $gitrepo->wc_path() || dirname($gitrepo->repo_path());
    my ($pipe, $c) =
        $gitrepo->command_output_pipe('ls-tree', '-r', '--format=%(path) %(objectname)', $head);
    while (my $line = <$pipe>) {
        chomp $line;
        my ($path, $hash) = split / /, $line, 2;
        printf $fh "added\x1F%s\x1F%s\x1F%s\x1F%s\x1E", $repo, $head, $path, $hash;
    }
    $gitrepo->command_close_pipe($pipe, $c);
    print $fh "\x1D";
}

sub genevents($gitrepo, $cached, $head, $fh = \*STDOUT) {
    my $repo = $gitrepo->wc_path() || dirname($gitrepo->repo_path());
    my ($pipe, $c) = $gitrepo->command_output_pipe('diff-tree', '--raw', $cached, $head);
    while (my $line = <$pipe>) {
        chomp $line;

        my @fields = split /\t/, $line, 2;
        next unless @fields == 2;

        my $info = $fields[0];
        my $path = $fields[1];

        my @parts = split / /, $info;
        next unless @parts >= 5;

        my $status = $parts[4];
        my $op;
        if ($status eq "A") {
            $op = "added";
        }
        elsif ($status eq "M") {
            $op = "changed";
        }
        elsif ($status eq "D") {
            $op = "removed";
        }
        else {
            next;
        }

        my $pathhash = ($status eq "D") ? $parts[2] : $parts[3];
        printf $fh "%s\x1F%s\x1F%s\x1F%s\x1F%s\x1E", $op, $repo, $head, $path, $pathhash;
    }
    $gitrepo->command_close_pipe($pipe, $c);
    print $fh "\x1D";
}

sub main() {
    my %opts;
    getopts('d', \%opts) or usage();
    $debug = 1 if $opts{d};

    my ($gitrepo, $repo) = eval {
        my $d = $ENV{GIT_WORK_TREE} || cwd();
        my $g = Git->repository(Directory => $d);
        my $r = $g->wc_path() || dirname($g->repo_path());
        ($g, $r);
    } or die "no git directory";
    dbg("repo=$repo");

    my $head = $gitrepo->command_oneline('rev-parse', 'HEAD');
    dbg("head=$head");

    my $runtimedir = getruntimedir();
    my $cachefile = "$runtimedir/roots$repo";
    my $commandpipe = "$runtimedir/command";
    dbg("runtimedir=$runtimedir");
    dbg("cachefile=$cachefile");
    dbg("commandpipe=$commandpipe");

    unless (-f $cachefile) {
        if (-p $commandpipe) {
            open my $fh, '>', $commandpipe or die "open $commandpipe: $!";
            firstrun($gitrepo, $head, $fh);
            close $fh;
            return;
        }

        dbg("daemon pipe not found, writing to stdout instead");
        firstrun($gitrepo, $head);
        return;
    }

    my $cached = do {
        open my $fh, '<', $cachefile or die "open $cachefile: $!";
        chomp(my $line = <$fh>);
        $line;
    };

    if ($cached eq $head) {
        dbg("no changes since last run");
        return;
    }

    if (-p $commandpipe) {
        open my $fh, '>', $commandpipe or die "open $commandpipe: $!";
        genevents($gitrepo, $cached, $head, $fh);
        close $fh;
        return;
    }

    dbg("daemon pipe not found, writing to stdout instead");
    genevents($gitrepo, $cached, $head);
}

main() unless caller;
