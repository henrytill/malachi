#!/usr/bin/env perl

use strict;
use warnings;

use Cwd;
use File::Basename;
use Getopt::Std;
use Git;

my $debug = 0;

sub usage {
	print STDERR <<EOF;
Usage: $0 [-d]

Options:
    -d          Enable debug output
EOF
	exit 1;
}

sub dbg {
	my $msg = shift;
	print STDERR "[DEBUG] $msg\n" if $debug;
}

sub getruntimedir {
	my $uid = $<;
	my $runtimedir = $ENV{XDG_RUNTIME_DIR} || "/run/user/$uid";
	if (-d $runtimedir && -w $runtimedir) {
		return "$runtimedir/malachi";
	}
	my $tmpdir = $ENV{TMPDIR} || "/tmp";
	return "$tmpdir/malachi-$uid";
}

sub firstrun {
	@_ >= 2 or die "usage: firstrun gitrepo head [filehandle]";
	my ($gitrepo, $head, $fh) = @_;
	$fh //= \*STDOUT;

	dbg("first run - generating add events for all files");
	my $repo = $gitrepo->wc_path() || dirname($gitrepo->repo_path());
	my ($pipe, $c) = $gitrepo->command_output_pipe('ls-tree', '-r', '--format=%(path) %(objectname)', $head);
	while (my $line = <$pipe>) {
		chomp $line;
		my ($path, $hash) = split / /, $line, 2;
		printf $fh "added\x1F%s\x1F%s\x1F%s\x1F%s\x1E", $repo, $head, $path, $hash;
	}
	$gitrepo->command_close_pipe($pipe, $c);
	print $fh "\x1D";
}

sub genevents {
	@_ >= 3 or die "usage: genevents gitrepo cached head [filehandle]";
	my ($gitrepo, $cached, $head, $fh) = @_;
	$fh //= \*STDOUT;

	my $repo = $gitrepo->wc_path() || dirname($gitrepo->repo_path());
	my ($pipe, $c) = $gitrepo->command_output_pipe('diff-tree', '--raw', $cached, $head);
	while (my $line = <$pipe>) {
		chomp $line;

		my @fields = split /\t/, $line, 2;
		next unless @fields == 2;

		my $info = $fields[0];
		my $path = $fields[1];

		my @parts = split / /, $info;
		next unless @parts >= 5;

		my $status = $parts[4];
		my $op;
		if ($status eq "A") {
			$op = "added";
		} elsif ($status eq "M") {
			$op = "changed";
		} elsif ($status eq "D") {
			$op = "removed";
		} else {
			next;
		}

		my $pathhash = ($status eq "D") ? $parts[2] : $parts[3];
		printf $fh "%s\x1F%s\x1F%s\x1F%s\x1F%s\x1E", $op, $repo, $head, $path, $pathhash;
	}
	$gitrepo->command_close_pipe($pipe, $c);
	print $fh "\x1D";
}

sub main {
	my %opts;
	getopts('d', \%opts) or usage();
	$debug = 1 if $opts{d};

	my $runtimedir = getruntimedir;
	dbg("runtimedir=$runtimedir");

	my $worktree = $ENV{GIT_WORK_TREE} || cwd();

	my ($gitrepo, $repo);
	eval {
		$gitrepo = Git->repository(Directory => $worktree);
		$repo = $gitrepo->wc_path() || dirname($gitrepo->repo_path());
	};
	if ($@) {
		die "no git directory";
	}

	my $head = $gitrepo->command_oneline('rev-parse', 'HEAD');
	dbg("repo=$repo");
	dbg("head=$head");

	my $cachefile = "$runtimedir/roots$repo";
	my $commandpipe = "$runtimedir/command";
	dbg("cachefile=$cachefile");
	dbg("commandpipe=$commandpipe");

	unless (-f $cachefile) {
		if (-p $commandpipe) {
			open my $fh, '>', $commandpipe or die "open $commandpipe: $!";
			firstrun($gitrepo, $head, $fh);
			close $fh;
			return;
		}

		dbg("daemon pipe not found, writing to stdout instead");
		firstrun($gitrepo, $head);
		return;
	}

	my $cached;
	{
		open my $fh, '<', $cachefile or die "open $cachefile: $!";
		$cached = <$fh>;
		chomp $cached;
	}

	if ($cached eq $head) {
		dbg("no changes since last run");
		return;
	}

	if (-p $commandpipe) {
		open my $fh, '>', $commandpipe or die "open $commandpipe: $!";
		genevents($gitrepo, $cached, $head, $fh);
		close $fh;
		return;
	}

	dbg("daemon pipe not found, writing to stdout instead");
	genevents($gitrepo, $cached, $head);
}

main() unless caller;

# Local Variables:
# indent-tabs-mode: t
# End:
